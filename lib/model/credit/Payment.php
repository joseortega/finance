<?php


/**
 * Skeleton subclass for representing a row from the 'credit_amortization' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Wed Apr 13 13:25:41 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.credit
 */
class Payment extends BasePayment
{  
  /**
   * The status attribute = unpaid
   */
  const STATUS_UNPAID = 'unpaid';
  
  /*
   * The status attribute = paid
   */
  const STATUS_PAID = 'paid';

    /**
   * Return true if this fee is canceled
   * 
   * @return boolean 
   */
  public function isPaid()
  {
    $b = false;
    
    if($this->getStatus() == self::STATUS_PAID){
      $b = true;
    }
    
    return $b;
  }
  
  /**
   * Return true if this fee has not been canceled
   * 
   * @return boolean 
   */
  public function isUnpaid()
  {
    $b = false;
    
    if($this->getStatus() == self::STATUS_UNPAID){
      $b = true;
    }
    
    return $b;
  }
  
  /**
   * Return true if this fee is in arrear
   * 
   * @return boolean 
   */
  public function isInArrear()
  {
    $b = false;
    
    if($this->getDaysInArrear() > 0){
      $b = true;
    }
    
    return $b;
  }
  
  /**
   * Return the days in arrear
   * 
   * @return int 
   */
  public function getDaysInArrear()
  {
    if($this->isUnpaid()){
      
      $paymentDate = $this->getDate('U') + $this->getCredit()->getProduct()->getGraceDays() * 86400;
    
      $now = mktime(0, 0, 0, date("m")  , date("d"), date("Y"));

      if($paymentDate >= $now){
        $daysInArrear = 0;
      }else{
        $daysInArrear = ($now - $paymentDate)/60/60/24;
      }
      
      $this->setDaysInArrear($daysInArrear);
    }
    
    return parent::getDaysInArrear();
  }
  
  /**
   * Return the arrear
   * 
   * @return decimal 
   */
  public function getArrear()
  {
    if($this->isUnpaid()){
      
      $arrear = 0.00;   
    
      if($this->isInArrear()){

        $arrearRate= $this->getCredit()->getProduct()->getArrearRateCurrent();
        
        if(!$arrearRate){
          $arrearRateValue = 0.00;
        }else{
          $arrearRateValue = $arrearRate->getValue();
        }

        $tea = $arrearRateValue;
        $n = $this->getDaysInArrear();
        $k = $this->getCapital();

        //According to the formula (((1+TEA/100)^(n/360))-1)*k
        $arrear = (pow((1+ ($tea/100)), $n/360)-1)*$k;
      }
      
      $arrear = round($arrear, 2);
      
      $this->setArrear($arrear);
    }
    
    return parent::getArrear(); 
  }
  
  /**
   * Get discount
   * 
   * @return decimal 
   */
  public function getDiscount() 
  {
    if($this->discount == null){

      $this->setDiscount(0);
    }
          
    return parent::getDiscount();
  }

  /**
   * Return the total payment
   * 
   * @return type 
   */
  public function getTotal()
  {
    $total = $this->getPreTotal() + $this->getArrear() - $this->getDiscount();
    
    return number_format(round($total,2), 2);
  }
  
  /**
   * Return the sum the Capital and interest
   * 
   * @return type 
   */
  public function getPreTotal()
  {
    return $this->getInterest() + $this->getCapital();
  }

    /**
   * Return the payment status 
   * 
   * @return string 
   */
  public function getStatusText() 
  {
    $statusText = 'unpaid';
    
    if($this->isPaid()){
      $statusText = 'paid';
    }elseif($this->isInArrear()){
      $statusText = 'in_arrear';
    }
    
    return $statusText;
  }
  
  /**
   * It records the payment
   * 
   * @param sfGuardUser $user
   * @param Cash $connection
   * @param TransactionType $actTransactionType
   * @param TransactionType $cdtTransactionType
   * @return CreditTransaction 
   */
  public function pay(sfGuardUser $user, TransactionType $actTransactionType, TransactionType $cdtTransactionType, PropelPDO $con = null)
  {
    $credit = $this->getCredit();
    $account = $credit->getAccount();
    $amount = $this->getTotal();
    
    if($con == null){
      $con = Propel::getConnection(PaymentPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
    }
   
    $con->beginTransaction();
    try {
      
      $actTransaction = new Transaction($user, $actTransactionType, $amount);
      $actTransaction->setAccount($account);
      $actTransaction->save($con);
      
      $account->debit($amount, $con);
      $actTransaction->updateAccountBalance($account->getBalance(), $con);

      $cdtTransaction = new Transaction($user, $cdtTransactionType, $amount);
      $cdtTransaction->setCredit($credit);
      $cdtTransaction->save($con);
     
      $credit->accredit($amount, $con);
      
      $this->setTransaction($cdtTransaction);
      $this->setStatus(Payment::STATUS_PAID);
      $this->setPaidAt(time());
      $this->save($con);
      
      if($credit->CountPaymentsPending()== 0){       
        $credit->setStatus(Credit::STATUS_PAID);  
        $credit->save($con);
      }
      
      $con->commit();

    } catch (Exception $e) {
      
      $con->rollBack();
      throw $e;
    }
    
    return $cdtTransaction;
  } 
} // CreditAmortization
