<?php


/**
 * Skeleton subclass for representing a row from the 'credit' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Sun Feb 20 16:26:33 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.credit
 */
class Credit extends BaseCredit 
{
  /**
   * status attribute = approved
   */
  const STATUS_APPROVED = 'approved';
  
  /**
   * status attribute = annulled
   */
  const STATUS_ANNULLED = 'annulled';
  
  /**
   * status attribute = in_request
   */
  const STATUS_IN_REQUEST = 'in_request';
  
  /**
   * status attribute = current
   */
  const STATUS_CURRENT = 'current';
  
  /**
   * status attribute = paid
   */
  const STATUS_PAID = 'paid';
  
  /**
   *
   * @param type $amount
   * @param PropelPDO $con 
   */
  public function accredit($amount, PropelPDO $con)
  {
    if($con == NULL){
        $con = Propel::getConnection(CreditPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
    }
    
    $con->beginTransaction();
    
    try {
        //set values $credit
        $this->setBalance($this->getBalance() + $amount);
        $this->save($con);
        
        $con->commit();
        
    } catch (Exception $e) {
        
        $con->rollBack();
    } 
  }
  
  /**
   *
   * @param type $amount
   * @param PropelPDO $con 
   */
  public function debit($amount, PropelPDO $con = null)
  {
    if($con == NULL){
      $con = Propel::getConnection(CreditPeer::DATABASE_NAME, Propel::CONNECTION_WRITE);
    }
    
    $con->beginTransaction();
    
    try {
        //set values $credit
        $this->setBalance($this->getBalance() - $amount);
        $this->save($con);
        
        $con->commit();
        
    } catch (Exception $e) {
        
        $con->rollBack();
    }
  }

  /**
   * Get isInRequest
   * 
   * @return boolean 
   */
  public function isInRequest()
  {
    return $this->CompareStatus(self::STATUS_IN_REQUEST);
  }

  /**
   * Get isApproved
   * 
   * @return boolean 
   */
  public function isApproved()
  {
    return $this->CompareStatus(self::STATUS_APPROVED);
  }

  /**
   * Get isAnnulled
   * 
   * @return boolean 
   */
  public function isAnnulled()
  {
    return $this->CompareStatus(self::STATUS_ANNULLED);
  }

  /**
   * Get isPaid
   * 
   * @return boolean 
   */
  public function isPaid()
  {
    return $this->CompareStatus(self::STATUS_PAID);
  }

  /**
   * Get isCurrent
   * 
   * @return boolean 
   */
  public function isCurrent()
  {
    return $this->CompareStatus(self::STATUS_CURRENT);
  }
  
  /**
   * Compare status credit
   * 
   * @param string $status credit status
   * @return boolean 
   */
  private function CompareStatus($status)
  {
    $b = false;
    if($this->getStatus() == $status){
      $b = true;
    }

    return $b;
  }
  
  /**
   * Get status text
   * 
   * @return string 
   */
  public function getStatusText()
  {
    $statusText = ucfirst(str_replace('_', ' ', $this->getStatus()));
    
    return $statusText;
  }

  /**
   * Count payments effected
     * 
   * @return int 
   */
  public function CountPaymentsEffected()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_PAID);
    
    return $this->countPayments($criteria);
  }
  
  /**
   * Get payments effected
   * 
   * @return amortizatios  
   */
  public function gePaymentsEffected()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_PAID, Criteria::EQUAL);
    
    return $this->getPayments($criteria);
  }
  
  /**
   * Count payments pending
   * 
   * @return int
   */
  public function CountPaymentsPending()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    
    return $this->countPayments($criteria);
  }
  
  /**
   * Get payments pending
   * 
   * @param int $limit Limit
   * @return  array amortizations 
   */
  public function getPaymentsPending($limit = null, $discount = true)
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::NUMBER);
    
    if($limit){
      $criteria->setLimit($limit);
    }else {
       $limit = $this->CountPaymentsPending(); 
    }
    
    $payments = $this->getPayments($criteria);
    
    if($discount == true){
        
        //se aplica descuentos de los intereses solo si el crÃ©dito se paga en su totalidad
        if($this->countPayments() == ($this->CountPaymentsEffected() + $limit)){
            
            $newPayments = array();
        
            foreach($payments as $payment){

                $paymentDate  = mktime(0, 0, 0, date("m", $payment->getDate('U')) - ($this->getPayFrequencyInMonths()), date("d", $payment->getDate('U')),   date("Y", $payment->getDate('U')));
                $nowDate = mktime(0, 0, 0, date("m"), date("d"), date("Y"));

                if($paymentDate >= $nowDate){
                    $payment->setDiscount($payment->getInterest());
                }

                $newPayments[] = $payment;
            }
            
            return $newPayments;  
        }       
    }
    
    return $payments;
  }
  
  /**
   * Get expired payments
   * 
   * @param int $limit
   * @return array 
   */
  public function getExpiredPayments($limit = null)
  {
    $now = mktime(0, 0, 0, date("m")  , date("d"), date("Y"));
    
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->add(PaymentPeer::DATE, $now, Criteria::LESS_EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::NUMBER);
    
    if($limit){
      $criteria->setLimit($limit);
    }
    
    return $this->getPayments($criteria);
  }

  /**
   * Get nex payment
   * 
   * @return Payment 
   */
  public function getNextPayment()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID, Criteria::EQUAL);
    $criteria->addAscendingOrderByColumn(PaymentPeer::ID);
    
    return PaymentPeer::doSelectOne($criteria);
  }
   
  /**
   * Get interest total
   * 
   * @return decimal 
   */
  public function getInterestTotal()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);

    $sum = PaymentPeer::sum(PaymentPeer::INTEREST, $criteria);
    
    return $sum;
  }
  
  /**
   * Get payment total
   * 
   * @return decimal 
   */
  public function getPaymentTotal()
  {
    $sum = $this->getCapitalTotal() + $this->getInterestTotal();
    
    return $sum;
  }
  
  /**
   * Get capital total
   * 
   * @return decimal 
   */ 
  public function getCapitalTotal()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId(), Criteria::EQUAL);

    $sum = PaymentPeer::sum(PaymentPeer::CAPITAL, $criteria);
    
    return $sum;
  }
  
  /**
   * Get payment pending
   * 
   * @return decimal 
   */
  public function getPaymentPending()
  {
    $criteria = new Criteria();
    $criteria->add(PaymentPeer::CREDIT_ID, $this->getId());
    $criteria->add(PaymentPeer::STATUS, Payment::STATUS_UNPAID);
    $criteria->addAscendingOrderByColumn(PaymentPeer::ID);
 
    $sum = PaymentPeer::sum(PaymentPeer::TOTAL, $criteria);
    
    return $sum;
  }

  /**
   * Get arrear pending
   * 
   * @return decimal
   */
  public function getArrearPending()
  {
    $payments = $this->getPaymentsPending();
    
    $arrear = 0.00;
    
    $arrear = PaymentPeer::sumArrear($payments);
    
    return $arrear;
  }
  
  /**
   * Get amount pending
   * 
   * @return decimal
   */
  public function getAmountPending()
  {
    $amount = $this->getArrearPending() + $this->getPaymentPending();
    
    return $amount;
  }
  
  /**
   *
   * @return decimal
   */
  public function getAverageMonthlyFee()
  {
    $product = $this->getProduct();
    $amount = $this->getAmount();
    $payFrequencyInMonths = $this->getPayFrequencyInMonths();
    $annualinterestRate = $product->getInterestRateCurrent() ? $product->getInterestRateCurrent()->getValue() : 0;
    $timeInMonths = $this->getTimeInMonths();
    
    if($annualinterestRate == 0.00){
      $total = $amount/$timeInMonths;
    }else{
      //To calculate the interest according to the frequency of payments in months
      $rate = $annualinterestRate/(12/$payFrequencyInMonths);
      $time = $timeInMonths/($payFrequencyInMonths);
      //calculate fee: (amount*rate)/(100*(1-(1+rate/100)^-time))
      $total = round(($amount*$rate)/(100*(1-pow(1+$rate/100,-$time))), 2);
    }

    return $total;
  }

  /**
   * Method toString
   * 
   * @return string getExpiredPayments
   */
  public function  __toString()
  {
    return $this->getId().' / '.$this->getAssociate()->getName();
  }
}
