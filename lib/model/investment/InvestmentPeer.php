<?php


/**
 * Skeleton subclass for performing query and update operations on the 'investment' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * Sun Feb 20 09:15:59 2011
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model.investment
 */
class InvestmentPeer extends BaseInvestmentPeer 
{
  /**
   * Count current
   * 
   * @return int 
   */
  public static function doCountCurrents()
  {
    $criteria = new Criteria();
    $criteria->add(self::IS_CURRENT, true, Criteria::EQUAL);
    
    return self::doCount($criteria);
  }
  
  /**
   * Count paid
   * 
   * @return type 
   */
  public static function doCountPaid()
  {
    $criteria = new Criteria();
    $criteria->add(self::IS_CURRENT, false, Criteria::EQUAL);
    
    return self::doCount($criteria);
  }
  
  /**
   * Count current and unpaid
   * 
   * @return int 
   */
  public static function doCountCurrentsAndUnpaid()
  {
    $criteria = new Criteria();
    $criteria->add(self::IS_CURRENT, true, Criteria::EQUAL);
    
    return self::doCount($criteria);
  }
  
  /**
   * Count current and expired
   * 
   * @return int 
   */
  public static function doCountCurrentExpired()
  {
    return self::doCount(self::addCriteriaExpired());
  }
  
  /**
   * Accredit to account
   * 
   * @param sfGuardUser $user
   * @param Cash $connection
   * @param type $investments
   * @param PropelPDO $con 
   */
  public static function accreditToAccount(sfGuardUser $user, Cash $connection, $investments = array(), PropelPDO $con = null)
  {
    foreach ($investments as $investment){
      $investment->accreditToAccount($user, $connection, $invTransactionType, $accountTransactionType, $con);
    }
  }
  
  /**
   * Interest capitalization
   * 
   * @param sfGuardUser $user
   * @param Cash $connection
   * @param type $investments
   * @param PropelPDO $con 
   */
  public static function interestCapitalization(sfGuardUser $user, Cash $connection, $investments = array(), PropelPDO $con = null)
  {
    foreach ($investments as $investment){
      $investment->interestCapitalization($user, $connection, $invTransactionType, $con);
    }
  }
  
  /**
   * Withholding tax
   * 
   * @param sfGuardUser $user
   * @param Cash $connection
   * @param type $investments
   * @param PropelPDO $con 
   */
  public static function withholdingTax(sfGuardUser $user, Cash $connection, $investments = array(), PropelPDO $con = null)
  {
    foreach ($investments as $investment){
      $investment->withholdingTax($user, $connection, $invTransactionType, $con);
    }
  }

  /**
   * Select current and expired
   * 
   * @return array object(Investment) 
   */
  public static function doSelectCurrentsExpired()
  {
    return self::doSelect(self::addCriteriaExpired());
  }
  
  /**
   * Add criteria current and expired
   * 
   * @param Criteria $criteria
   * @return Criteria 
   */
  public static function addCriteriaExpired(Criteria $criteria = null)
  {
    if($criteria == null){
      $criteria = new Criteria();
    }
    
    $now = mktime(0, 0, 0, date("m"), date("d"), date("Y"));
    
    $criteria = new Criteria();
    $criteria->add(self::IS_CURRENT, true, Criteria::EQUAL);
    $criteria->add(self::EXPIRATION_DATE, $now, Criteria::LESS_EQUAL);
    
    return $criteria;
  }

    /**
   * Retrieve for select
   * 
   * @param string $q
   * @param int $limit
   * @return array object(Account) 
   */
  static public function retrieveForSelect($q, $limit)
  {
    $criteria = new Criteria();
    $criteria->add(self::ID, '%'.$q.'%', Criteria::LIKE);
    $criteria->addAscendingOrderByColumn(self::ID);
    $criteria->setLimit($limit);
 
    $investments = array();
    foreach (self::doSelect($criteria) as $investment)
    {
      $investments[$investment->getId()] = (string) $investment;
    }
 
    return $investments;
  }
} // InvestmentPeer
